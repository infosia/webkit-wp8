2013-10-14  Mark Lam  <mark.lam@apple.com>

        Transition *switch* and *scope* JITStubs to JIT operations.
        https://bugs.webkit.org/show_bug.cgi?id=122757.

        Reviewed by Geoffrey Garen.

        Transitioning:
            cti_op_switch_char
            cti_op_switch_imm
            cti_op_switch_string
            cti_op_resolve_scope
            cti_op_get_from_scope
            cti_op_put_to_scope

        * jit/JIT.h:
        * jit/JITInlines.h:
        (JSC::JIT::callOperation):
        * jit/JITOpcodes.cpp:
        (JSC::JIT::emit_op_switch_imm):
        (JSC::JIT::emit_op_switch_char):
        (JSC::JIT::emit_op_switch_string):
        * jit/JITOpcodes32_64.cpp:
        (JSC::JIT::emit_op_switch_imm):
        (JSC::JIT::emit_op_switch_char):
        (JSC::JIT::emit_op_switch_string):
        * jit/JITOperations.cpp:
        * jit/JITOperations.h:
        * jit/JITPropertyAccess.cpp:
        (JSC::JIT::emitSlow_op_resolve_scope):
        (JSC::JIT::emitSlow_op_get_from_scope):
        (JSC::JIT::emitSlow_op_put_to_scope):
        * jit/JITPropertyAccess32_64.cpp:
        (JSC::JIT::emitSlow_op_resolve_scope):
        (JSC::JIT::emitSlow_op_get_from_scope):
        (JSC::JIT::emitSlow_op_put_to_scope):
        * jit/JITStubs.cpp:
        * jit/JITStubs.h:

2013-10-14  Filip Pizlo  <fpizlo@apple.com>

        DFG PutById IC should use the ConcurrentJITLocker since it's now dealing with IC's that get read by the compiler thread
        https://bugs.webkit.org/show_bug.cgi?id=122786

        Reviewed by Mark Hahnenberg.

        * bytecode/CodeBlock.cpp:
        (JSC::CodeBlock::resetStub): Resetting a stub should acquire the lock since this is observable from the thread; but we should only acquire the lock if we're resetting outside of GC.
        * jit/Repatch.cpp:
        (JSC::repatchPutByID): Doing the PutById patching should hold the lock.
        (JSC::buildPutByIdList): Ditto.

2013-10-14  Nadav Rotem  <nrotem@apple.com>

        Add FTL support for LogicalNot(string)
        https://bugs.webkit.org/show_bug.cgi?id=122765

        Reviewed by Filip Pizlo.

        This patch is tested by:
        regress/script-tests/emscripten-cube2hash.js.ftl-eager

        * ftl/FTLCapabilities.cpp:
        (JSC::FTL::canCompile):
        * ftl/FTLLowerDFGToLLVM.cpp:
        (JSC::FTL::LowerDFGToLLVM::compileLogicalNot):

2013-10-14  Julien Brianceau  <jbriance@cisco.com>

        [sh4] Fixes after r157404 and r157411.
        https://bugs.webkit.org/show_bug.cgi?id=122782

        Reviewed by Michael Saboff.

        * dfg/DFGSpeculativeJIT.h:
        (JSC::DFG::SpeculativeJIT::callOperation): Add missing SH4_32BIT_DUMMY_ARG.
        * jit/CCallHelpers.h:
        (JSC::CCallHelpers::setupArgumentsWithExecState):
        * jit/JITInlines.h:
        (JSC::JIT::callOperation): Add missing SH4_32BIT_DUMMY_ARG.
        * jit/JITPropertyAccess32_64.cpp:
        (JSC::JIT::emit_op_put_by_id): Remove unwanted BEGIN_UNINTERRUPTED_SEQUENCE.

2013-10-14  Commit Queue  <commit-queue@webkit.org>

        Unreviewed, rolling out r157413.
        http://trac.webkit.org/changeset/157413
        https://bugs.webkit.org/show_bug.cgi?id=122779

        Appears to have caused frequent crashes (Requested by ap on
        #webkit).

        * CMakeLists.txt:
        * GNUmakefile.list.am:
        * JavaScriptCore.vcxproj/JavaScriptCore.vcxproj:
        * JavaScriptCore.vcxproj/JavaScriptCore.vcxproj.filters:
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * heap/DeferGC.cpp: Removed.
        * heap/DeferGC.h:
        * jit/JITStubs.cpp:
        (JSC::tryCacheGetByID):
        (JSC::DEFINE_STUB_FUNCTION):
        * llint/LLIntSlowPaths.cpp:
        (JSC::LLInt::LLINT_SLOW_PATH_DECL):
        * runtime/ConcurrentJITLock.h:
        * runtime/InitializeThreading.cpp:
        (JSC::initializeThreadingOnce):
        * runtime/JSCellInlines.h:
        (JSC::allocateCell):
        * runtime/Structure.cpp:
        (JSC::Structure::materializePropertyMap):
        (JSC::Structure::putSpecificValue):
        (JSC::Structure::createPropertyMap):
        * runtime/Structure.h:

2013-10-14  Mark Hahnenberg  <mhahnenberg@apple.com>

        COLLECT_ON_EVERY_ALLOCATION causes assertion failures
        https://bugs.webkit.org/show_bug.cgi?id=122652

        Reviewed by Filip Pizlo.

        COLLECT_ON_EVERY_ALLOCATION wasn't accounting for the new GC deferral mechanism,
        so we would end up ASSERTing during garbage collection.

        * heap/MarkedAllocator.cpp:
        (JSC::MarkedAllocator::allocateSlowCase):

2013-10-11  Oliver Hunt  <oliver@apple.com>

        Separate out array iteration intrinsics
        https://bugs.webkit.org/show_bug.cgi?id=122656

        Reviewed by Michael Saboff.

        Separate out the intrinsics for key and values iteration
        of arrays.

        This requires moving moving array iteration into the iterator
        instance, rather than the prototype, but this is essentially
        unobservable so we'll live with it for now.

        * jit/ThunkGenerators.cpp:
        (JSC::arrayIteratorNextThunkGenerator):
        (JSC::arrayIteratorNextKeyThunkGenerator):
        (JSC::arrayIteratorNextValueThunkGenerator):
        * jit/ThunkGenerators.h:
        * runtime/ArrayIteratorPrototype.cpp:
        (JSC::ArrayIteratorPrototype::finishCreation):
        * runtime/Intrinsic.h:
        * runtime/JSArrayIterator.cpp:
        (JSC::JSArrayIterator::finishCreation):
        (JSC::createIteratorResult):
        (JSC::arrayIteratorNext):
        (JSC::arrayIteratorNextKey):
        (JSC::arrayIteratorNextValue):
        (JSC::arrayIteratorNextGeneric):
        * runtime/VM.cpp:
        (JSC::thunkGeneratorForIntrinsic):

2013-10-11  Mark Hahnenberg  <mhahnenberg@apple.com>

        llint_slow_path_put_by_id can deadlock on a ConcurrentJITLock
        https://bugs.webkit.org/show_bug.cgi?id=122667

        Reviewed by Filip Pizlo.

        The issue this patch is attempting to fix is that there are places in our codebase
        where we acquire the ConcurrentJITLock for a particular CodeBlock, then we do some
        operations that can initiate a garbage collection. Garbage collection then calls 
        some methods of CodeBlock that also take the ConcurrentJITLock (because they don't
        always necessarily run during garbage collection). This causes a deadlock.

        To fix this issue, this patch adds a new RAII-style object (DisallowGC) that stores 
        into a thread-local field that indicates that it is unsafe to perform any operation 
        that could trigger garbage collection on the current thread. In debug builds, 
        ConcurrentJITLocker contains one of these DisallowGC objects so that we can eagerly 
        detect deadlocks.

        This patch also adds a new type of ConcurrentJITLocker, GCSafeConcurrentJITLocker,
        which uses the DeferGC mechanism to prevent collections from occurring while the 
        lock is held.

        * CMakeLists.txt:
        * GNUmakefile.list.am:
        * JavaScriptCore.vcxproj/JavaScriptCore.vcxproj:
        * JavaScriptCore.vcxproj/JavaScriptCore.vcxproj.filters:
        * JavaScriptCore.xcodeproj/project.pbxproj:
        * heap/DeferGC.cpp: Added.
        * heap/DeferGC.h:
        (JSC::DisallowGC::DisallowGC):
        (JSC::DisallowGC::~DisallowGC):
        (JSC::DisallowGC::isGCDisallowedOnCurrentThread):
        (JSC::DisallowGC::initialize):
        * jit/JITStubs.cpp:
        (JSC::tryCachePutByID):
        (JSC::tryCacheGetByID):
        (JSC::DEFINE_STUB_FUNCTION):
        * llint/LLIntSlowPaths.cpp:
        (JSC::LLInt::LLINT_SLOW_PATH_DECL):
        * runtime/ConcurrentJITLock.h:
        (JSC::ConcurrentJITLockerBase::ConcurrentJITLockerBase):
        (JSC::ConcurrentJITLockerBase::~ConcurrentJITLockerBase):
        (JSC::ConcurrentJITLockerBase::unlockEarly):
        (JSC::GCSafeConcurrentJITLocker::GCSafeConcurrentJITLocker):
        (JSC::ConcurrentJITLocker::ConcurrentJITLocker):
        * runtime/InitializeThreading.cpp:
        (JSC::initializeThreadingOnce):
        * runtime/JSCellInlines.h:
        (JSC::allocateCell):
        * runtime/Structure.cpp:
        (JSC::Structure::materializePropertyMap):
        (JSC::Structure::putSpecificValue):
        (JSC::Structure::createPropertyMap):
        * runtime/Structure.h:

2013-10-14  Filip Pizlo  <fpizlo@apple.com>

        Baseline JIT should use the DFG's PutById IC
        https://bugs.webkit.org/show_bug.cgi?id=122704

        Reviewed by Mark Hahnenberg.
        
        Mostly no big deal, just removing the old Baseline JIT's put_by_id IC support and forcing
        that JIT to use the DFG's (i.e. JITOperations) PutById IC.
        
        The only complicated part was that the PutById operations assumed that we first did a
        cell speculation, which the baseline JIT obviously won't do. So I changed all of those
        slow paths to deal with EncodedJSValue's.

        * bytecode/CodeBlock.cpp:
        (JSC::CodeBlock::resetStubInternal):
        * bytecode/PutByIdStatus.cpp:
        (JSC::PutByIdStatus::computeFor):
        * dfg/DFGSpeculativeJIT.h:
        (JSC::DFG::SpeculativeJIT::callOperation):
        * dfg/DFGSpeculativeJIT32_64.cpp:
        (JSC::DFG::SpeculativeJIT::cachedPutById):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::cachedPutById):
        * jit/CCallHelpers.h:
        (JSC::CCallHelpers::setupArgumentsWithExecState):
        * jit/JIT.cpp:
        (JSC::PropertyStubCompilationInfo::copyToStubInfo):
        * jit/JIT.h:
        (JSC::PropertyStubCompilationInfo::PropertyStubCompilationInfo):
        (JSC::PropertyStubCompilationInfo::slowCaseInfo):
        * jit/JITInlines.h:
        (JSC::JIT::callOperation):
        * jit/JITOperationWrappers.h:
        * jit/JITOperations.cpp:
        * jit/JITOperations.h:
        * jit/JITPropertyAccess.cpp:
        (JSC::JIT::compileGetByIdHotPath):
        (JSC::JIT::compileGetByIdSlowCase):
        (JSC::JIT::emit_op_put_by_id):
        (JSC::JIT::emitSlow_op_put_by_id):
        * jit/JITPropertyAccess32_64.cpp:
        (JSC::JIT::compileGetByIdSlowCase):
        (JSC::JIT::emit_op_put_by_id):
        (JSC::JIT::emitSlow_op_put_by_id):
        * jit/JITStubs.cpp:
        * jit/JITStubs.h:
        * jit/Repatch.cpp:
        (JSC::appropriateGenericPutByIdFunction):
        (JSC::appropriateListBuildingPutByIdFunction):
        (JSC::resetPutByID):

2013-10-13  Filip Pizlo  <fpizlo@apple.com>

        FTL should have an inefficient but correct implementation of GetById
        https://bugs.webkit.org/show_bug.cgi?id=122740

        Reviewed by Mark Hahnenberg.
        
        It took some effort to realize that the node->prediction() check in the DFG backends
        are completely unnecessary since the ByteCodeParser will always insert a ForceOSRExit
        if !prediction.
        
        But other than that this was an easy patch.

        * dfg/DFGByteCodeParser.cpp:
        (JSC::DFG::ByteCodeParser::handleGetById):
        * dfg/DFGSpeculativeJIT32_64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * dfg/DFGSpeculativeJIT64.cpp:
        (JSC::DFG::SpeculativeJIT::compile):
        * ftl/FTLCapabilities.cpp:
        (JSC::FTL::canCompile):
        * ftl/FTLIntrinsicRepository.h:
        * ftl/FTLLowerDFGToLLVM.cpp:
        (JSC::FTL::LowerDFGToLLVM::compileNode):
        (JSC::FTL::LowerDFGToLLVM::compileGetById):

2013-10-13  Mark Lam  <mark.lam@apple.com>

        Transition misc cti_op_* JITStubs to JIT operations.
        https://bugs.webkit.org/show_bug.cgi?id=122645.

        Reviewed by Michael Saboff.

        Stubs converted:
            cti_op_check_has_instance
            cti_op_create_arguments
            cti_op_del_by_id
            cti_op_instanceof
            cti_to_object
            cti_op_push_activation
            cti_op_get_pnames
            cti_op_load_varargs

        * dfg/DFGOperations.cpp:
        * dfg/DFGOperations.h:
        * jit/CCallHelpers.h:
        (JSC::CCallHelpers::setupArgumentsWithExecState):
        * jit/JIT.h:
        (JSC::JIT::emitStoreCell):
        * jit/JITCall.cpp:
        (JSC::JIT::compileLoadVarargs):
        * jit/JITCall32_64.cpp:
        (JSC::JIT::compileLoadVarargs):
        * jit/JITInlines.h:
        (JSC::JIT::callOperation):
        * jit/JITOpcodes.cpp:
        (JSC::JIT::emit_op_get_pnames):
        (JSC::JIT::emit_op_create_activation):
        (JSC::JIT::emit_op_create_arguments):
        (JSC::JIT::emitSlow_op_check_has_instance):
        (JSC::JIT::emitSlow_op_instanceof):
        (JSC::JIT::emitSlow_op_get_argument_by_val):
        * jit/JITOpcodes32_64.cpp:
        (JSC::JIT::emitSlow_op_check_has_instance):
        (JSC::JIT::emitSlow_op_instanceof):
        (JSC::JIT::emit_op_get_pnames):
        (JSC::JIT::emit_op_create_activation):
        (JSC::JIT::emit_op_create_arguments):
        (JSC::JIT::emitSlow_op_get_argument_by_val):
        * jit/JITOperations.cpp:
        * jit/JITOperations.h:
        * jit/JITPropertyAccess.cpp:
        (JSC::JIT::emit_op_del_by_id):
        * jit/JITPropertyAccess32_64.cpp:
        (JSC::JIT::emit_op_del_by_id):
        * jit/JITStubs.cpp:
        * jit/JITStubs.h:

2013-10-13  Filip Pizlo  <fpizlo@apple.com>

        FTL OSR exit should perform zero extension on values smaller than 64-bit
        https://bugs.webkit.org/show_bug.cgi?id=122688

        Reviewed by Gavin Barraclough.
        
        In the DFG we usually make the simplistic assumption that a 32-bit value in a 64-bit
        register will have zeros on the high bits.  In the few cases where the high bits are
        non-zero, the DFG sort of tells us this explicitly.

        But when working with llvm.webkit.stackmap, it doesn't work that way.  Consider we might
        emit LLVM IR like:

            %2 = trunc i64 %1 to i32
            stuff %2
            call @llvm.webkit.stackmap(...., %2)

        LLVM may never actually emit a truncation instruction of any kind.  And that's great - in
        many cases it won't be needed, like if 'stuff %2' is a 32-bit op that ignores the high
        bits anyway.  Hence LLVM may tell us that %2 is in the register that still had the value
        from before truncation, and that register may have garbage in the high bits.

        This means that on our end, if we want a 32-bit value and we want that value to be
        zero-extended, we should zero-extend it ourselves.  This is pretty easy and should be
        cheap, so we should just do it and not make it a requirement that LLVM does it on its
        end.
        
        This makes all tests pass with JSC_ftlOSRExitUsesStackmap=true.

        * ftl/FTLOSRExitCompiler.cpp:
        (JSC::FTL::compileStubWithOSRExitStackmap):
        * ftl/FTLValueFormat.cpp:
        (JSC::FTL::reboxAccordingToFormat):

== Rolled over to ChangeLog-2013-10-13 ==
